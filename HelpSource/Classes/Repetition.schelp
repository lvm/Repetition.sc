class:: Repetition
summary:: A (tiny) dialect for building patterns, *heavily* inspired by TidalCycles.
categories:: Live Coding
related:: Classes/Prepetition

DESCRIPTION::
A (tiny) dialect for building patterns, *heavily* inspired by TidalCycles.


note::
This software is sort of experimental, mainly an exploration of SuperCollider + Live Coding.
::


So far, I've implemented only these possibilities:

LIST::
## Polyrhythms: code::"a | b"::
## Groups: code::"a+b"::
## Accents: code::"a@"::
## Shift octave up: code::"a'"::
## Shift octave down: code::"a,"::
## Repetition: code::"a!"::
## Multiplication: code::"a*N":: (teletype::N -> Int::)
::

All of this is "chainable".

SUBSECTION:: Quickstart

A fairly complex pattern:

code::
"bd*3 | hq@+sn rm@! cp@".parseRepetitionPattern;
::

Is converted to:

code::
-> [
    ( 'pattern': [ bd, bd, bd ],
      'accent': [ 0, 0, 0 ],
      'time': [ 0.33333333333333, 0.33333333333333, 0.33333333333333 ],
      'oct': [ 0, 0, 0 ],
    ),
    ( 'pattern': [ hq, sn, rm, rm, cp ],
      'accent': [ 0.25, 0, 0.25, 0.25, 0.25 ],
      'time': [ 0.125, 0.125, 0.25, 0.25, 0.25 ],
      'oct': [ 0, 0, 0 ],
    )
   ]
::

A polymeter:

code::
x = "5@ x*4 | 4@ x*3".parseRepetitionPattern
::

code::
-> [
    ( 'pattern': [ 5, x, x, x, x ],
      'accent': [ 0.25, 0, 0, 0, 0 ],
      'time': [ 0.2, 0.2, 0.2, 0.2, 0.2 ],
      'oct': [ 0, 0, 0 ],
    ),
    ( 'pattern': [ 4, x, x, x ],
      'accent': [ 0.25, 0, 0, 0 ],
      'time': [ 0.25, 0.25, 0.25, 0.25 ],
      'oct': [ 0, 0, 0 ],
    )
   ]
::

To "see" what's going on, it's possible to:

code::
x[0].pattern.dup(4).flat;
x[1].pattern.dup(5).flat;
//-> [ 5, x, x, x, x, 5, x, x, x, x, 5, x, x, x, x, 5, x, x, x, x ]
//-> [ 4, x, x, x, 4, x, x, x, 4, x, x, x, 4, x, x, x, 4, x, x, x ]
::

A simple link::Classes/Pbind:::

code::
(
~x = "0 0+3 7".asRepetition(\tempo, 60/60, \type, \md, \chan, 2, \amp, 0.75);
)
::

That is equivalent to:

code::
(
var notes = "0 0+3 7".parseRepetitionPattern.pop;
~x = Pbind(
  \tempo, 60/60,
  \type, \md,
  \amp, Pseq(notes.amp, inf) + 0.75,
  \dur, Pseq(notes.time, inf),
  \midinote, Pseq(notes.pattern.collect(_.asInt), inf) + 60,
  \sustain, Pkey(\dur),
  \chan, 2,
);
)
::

Another a bit more complex link::Classes/Pbind:: example:

code::
(
var pbd = [\tempo, 60/60, \type, \md, \amp, 0.5];
var drum = pbd ++ [\chan, 9, \cb: \asPerc];
var test = "bd sn | ch*3 | 0@ 4 7 0 9 0".parseRepetitionPattern;
~q = test.at(0).asPbind(drum ++ [\stut, 2]);
~w = test.at(1).asPbind(drum ++ [\stretch, Pseq([1,1/4,1/2,2].stutter(4),inf)]);
~e = test.at(2).asPbind(pbd ++ [\chan, 4, \octave, Pseq([3,4,5],inf), \cb: \asInt, \amp, 0.7]);
)
::


In which I defined a dict, code::pbd::, which later is blended with
code::drum:: another dict which defines a midi channel. Later on, code::drum::
is blended once again with different settings, once using code::stut:: that
internally is translated to a link::Classes/Pstutter:: and the other uses
code::\stretch:: that modifies the value of code::\dur:: (0.3, 0.075, 0.15,
0.6) repeated 4 times each.  Also, a _bass_ midi-synth is defined with
code::octave:: which cycles twice in the same pattern: 0/3, 4/4, 7/5, 0/3, 9/4,
0/5.  Finally, each dict has code::cb::, which is basically a _callback_ over
the current note being played.

Another example using link::Classes/ChordProg::. Patterns can be built from arrays
as well.

code::
(
var chord = (
  \c: \min,
  \gs: \maj,
  \a: \min,
);
var p = [\c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \gs, \c, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \a, \gs, \a].collect{
  |n|
  ChordProg.getChord(n, chord[n])
}.flat.join(" ");
~kindofpolynomialc = p.asRepetition(\tempo, 60/60, \cb, \asInt, \chan, 4, \stretch, 26, \type, \md, \amp, 0.8);
)
::


Or if you're using the same instrument for the polyrhythm, you can 'group' them:

code::
(
~pr = "bd sn | ch*3 | r cp r".asGroupRepetition(\tempo, 60/60, \chan, 9, \cb, \asPerc, \type, \md, \amp, 0.5);
)
::

SUBSECTION:: Backend

Originally, it would try to guess where to send the current value, for example, if we were using an Event type code::\midi::, it would send the current value to code::\midinote::. Now it's required to pass an extra argument to the Pbind called code::to::. This way it's easier to specify where to send the current value.

For example, we can use C3, C4, C5 as the frequencies to pass to an imaginary LPF Filter via MIDI CC.
code::
(
~fun = "c".asRepetition(\chan, 7, \cb, \asFreq, \to, \control, \tempo, 60/60, \octave, Pseq([3,4,5],inf), \type, \cc, \amp, 1);
)
::

SUBSECTION:: Callbacks

It affects the current event (from pattern) and applies a certain function:

LIST::
## code::\asInt::, converts to integer
## code::\asPerc::, converts to midi note. See link::Classes/PercSymbol:: for more info
## code::\asChord::, which takes an additional argument code::\chord::
## code::\asSynth::, which should be used with code::\type::, code::\dirt::, otherwise the value will be passed as code::\note::
## code::\asFn::, which takes an additional arg code::\fn:: (which should be a function), which will receive two args: current perc value and the whole event
## code::\asFreq::, which tries to convert a note (chromatic scale) to a frequency (using code::.midicps::)
## code::\asSemitone::, which tries to convert a note (chromatic scale) to its semitone (code::0..12::)
## code::\asCC::, which tries to convert the current value (Float) to a MIDI CC value (code::0..127::)
::


This example will play the following chords: teletype::Cmin, DMaj, EMaj7::

code::
(
~ccc = "c d e".asRepetition(\tempo, 60/60, \octave, 5, \type, \md, \amp, 0.5, \chan, 4, \cb, \asChord, \chord, Pseq([\min,\maj,\maj7],inf));
)
::


This other example, will add a number between 12 and 24 to the current midinote.  Also notice
code::octave: 0::.  That is because in this particular case, since it's a Event
type MIDI, it'll add automatically code::octave: 5::, so 36 (bd) instead of
ending between 48 and 60, it would end between 108 and 120 (code::octave: 5::
equals to current-note + code::12*Pkey(\octave))::.

code::
(
~fun = "bd".asRepetition(\tempo, 60/60, \type, \md, \amp, 0.5, \chan, 9, \cb, \asFn, \fn, {|x| [x].asGMPerc + (12..24).choose }, \octave, 0);
)
::


SUBSECTION:: Bjorklund / Euclidean Rhythm

Repetition isn't flexible as Tidal itself but taking advantage of the
link::Classes/Bjorklund:: Quark, we are able to generate a link::Classes/String:: that represent the
same rhythm. The valid args are code::k:: which represents the amount of notes
distributed in code::n:: places, and code::rotate:: which will shift positions.

For example:

code::
"bd".asBjorklund(4, 16).quote;
//=> "bd r r r bd r r r bd r r r bd r r r"
::

code::
"bd".asBjorklund(4, 16, 2).quote;
//=> "r r bd r r r bd r r r bd r r r bd r"
::

Additionally, it's possible to pass more than one 'symbol' as a Bjorklund
pattern, such as "sn rm", which is converted to a group, "sn+rm", therefore
creating a _longer_ pattern but maintaining the same duration.

For example:

code::
"bd sn".asBjorklund(1,4).parseRepetitionPattern
//=> "bd+sn r r r"
//=> [
//    ( 'pattern': [ bd, sn, r, r, r ],
//      'time': [ 0.125, 0.125, 0.25, 0.25, 0.25 ],
//      'accent': [ 0, 0, 0, 0, 0 ]
//    )
//   ]
::

So, instead of dividing each value by the total amount (1/5), it's divided by
1/4 and the group by the amount of items in it (1/2). This can be seen clearly
in the 'time' Array.

An example chaining Bjorklund/Euclidean rhythms:

code::
(
var pat = (("bd".asBjorklund(3,8))+"| r r r sn r r | r ch ch@ ch |"+("rm".asBjorklund(5,8))+"|cp");
~pbj = pat.asGroupRepetition(\tempo, 60/60, \type, \md, \amp, 0.75, \chan, 9, \cb, \asPerc);
)
::

SUBSECTION:: Custom MIDI Event Types

Currently, link::Classes/Repetition:: provides two custom link::Classes/Event:: types: code::\md:: and code::\cc::. Both are a simplification of a normal link::Classes/Event:: type code::\midi:: declaring by default code::~type::, code::~midiout::, code::~chan:: (code::9:: by default) and code::~amp::.
To use them you just need to call code::Repetition.initMIDI:: and code::Repetition.midiEventTypes:: .
Example:

code::
(
r = Repetition.new;
m = r.initMIDI("Midi Through", "Midi Through Port-0");
r.midiEventTypes;
)
::


SUBSECTION:: External Methods

Also, I've added the most common link::Classes/Pattern:: classes as methods, there isn't a really good reason other than it's more comfortable to type when chaining methods.

code::
(
16.collect{ |x| x + x.rand(x, x*2) }.stutter(8).scramble.asPseq(rep: inf, offs: 0);
[1,2,3].asPwrand([0.1,0.5,0.23].normalizeSum, inf).stutter(8);
)
::

The available methods are:

LIST::
## code::asPseq::, takes two arguments: code::rep:: (repeats) and code::offs:: (offset).
## code::asPshuf::, takes one argument: code::rep:: (repeats).
## code::asPrand::, takes one argument: code::rep:: (repeats).
## code::asPxrand::, takes one argument: code::rep:: (repeats).
## code::asPwrand::, takes two arguments: code::weights:: (weights) and code::rep:: (repeats).
## code::asPlace::, takes two arguments: code::rep:: (repeats) and code::offs:: (offset).
::


SUBSECTION:: Shortcuts

In case you don't feel like typing those extra characters, there are a couple of shortcuts available:

LIST::
## code::rp::, for code::asRepetition::
## code::grp::, for code::asGroupRepetition::
## code::bj::, for code::asBjorklund::
## code::ps::, for code::asPseq::
## code::psh::, for code::asPshuf::
## code::pr::, for code::asPrand::
## code::px::, for code::asPxrand::
## code::pw::, for code::asPwrand::
## code::pl::, for code::asPlace::
::


SUBSECTION:: Booting up

And last but not least, the recommended way [*] to boot SuperCollider link::Classes/Server:: + link::Classes/ProxySpace:: with link::Classes/Repetition::

code::
(
r = Repetition.new;
m = r.initMIDI("Midi Through", "Midi Through Port-0");
MIDIIn.connectAll;
r.midiEventTypes;  // setup repetition midi stuff
ProxyMixer(r.getProxySpace); // and a nice proxymixer too
)
::

[*] At least, how I do it :-)


CLASSMETHODS::

METHOD:: new
Creates a Repetition instance, which will automatically boot the link::Classes/Server:: + link::Classes/ProxySpace::

ARGUMENT:: default_tempo
Defines the tempo clock for link::Classes/ProxySpace::

ARGUMENT:: quant
Defines the quantization for link::Classes/ProxySpace::

returns:: link::Classes/Repetition::


INSTANCEMETHODS::

METHOD:: start
Creates a Repetition instance, which will automatically boot the link::Classes/Server:: + link::Classes/ProxySpace::

ARGUMENT:: default_tempo
Defines the tempo clock for link::Classes/ProxySpace::

ARGUMENT:: quant
Defines the quantization for link::Classes/ProxySpace::

returns:: link::Classes/Repetition::


METHOD:: initSuperDirt
(describe method here)
Starts link::Classes/SuperDirt:: with pretty much default settings, except it starts with 8 orbits (4 stereo) instead of just 2

returns:: link::Classes/SuperDirt::


METHOD:: initMIDI
Starts link::Classes/MIDIClient:: if not running, and creates link::Classes/MIDIOut:: instance

ARGUMENT:: dev
Device name. See link::Classes/MIDIOut::

ARGUMENT:: port
Port name. See link::Classes/MIDIOut::

ARGUMENT:: latency
MIDI Latency. See link::Classes/MIDIOut::

returns:: link::Classes/MIDIOut::


METHOD:: midiEventTypes
Creates two link::Classes/Event:: types, code::\md:: and code::\cc::

returns:: link::Classes/Repetition::


METHOD:: on
Sends a Note On to a MIDI Channel

ARGUMENT:: chan
Channel number

ARGUMENT:: note
MIDI Note number

ARGUMENT:: vel
MIDI Velocity

returns:: link::Classes/Repetition::


METHOD:: off
Sends a Note Off to a MIDI Channel

ARGUMENT:: chan
Channel number

returns:: link::Classes/Repetition::


METHOD:: getProxySpace
Returns the link::Classes/ProxySpace:: instance

returns:: link::Classes/ProxySpace::
