class:: Repetition
summary:: A set of tools for building a List of Events.
categories:: Live Coding
related:: Guides/Cheatsheet

DESCRIPTION::
A set of tools for building a List of Events. Inspired by TidalCycles.

note::
This software is sort of experimental, mainly an exploration of SuperCollider + Live Coding.

::


So far, I've implemented only these possibilities:

LIST::
## Polyrhythms: code::"a | b":: (this will change)
## Groups: code::"a+b"::
## Accents: code::"a@"::
## Shift octave up: code::"a'"::
## Shift octave down: code::"a,"::
## Repetition: code::"a!"::
## Multiplication: code::"a*N":: (teletype::N -> Int::)
::

All of this is "chainable".

SUBSECTION:: Quickstart

A fairly complex pattern:

code::
"a*3 b@+c d@! e@".repetitionPattern;
::

Is converted to:

code::
-> [
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0 ),
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0 ),
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0 ),
  ( 'octave': 5, 'dur': 0.071428571428571, 'accent': 0.25 ),
  ( 'octave': 5, 'dur': 0.071428571428571, 'accent': 0 ),
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0.25 ),
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0.25 ),
  ( 'octave': 5, 'dur': 0.14285714285714, 'accent': 0.25 )
]
::


SUBSECTION:: Callbacks

The main method, code::.repetitionPattern::, takes two arguments:
The 1st is a list of callbacks that convert the link::Classes/Repetition:: Pattern to a List of Events.
The 2nd is the octave in which we're playing.

LIST::
## code::\perc::, converts to midi note. See link::Classes/PercSymbol:: for more info
## code::\chord::, converts to a list of Note
## code::\degree::, converts a Note (ABC Format) to its semitone (code::0..12::)
## code::\freq::, converts a Note (ABC Format) to its frequency
## code::\int::, converts to integer
::

These callbacks can be used by passing them as the 1st argument of

code::
"bd sn".repetitionPattern(\perc);
"bd sn".perc;
-> [
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': 36 ),
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': 38 )
]
::

code::
"cmaj dmaj7".repetitionPattern(\chord, 5);
"cmaj dmaj7".chord(5);
-> [
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': [ 60, 64, 67 ] ),
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': [ 62, 66, 69, 73 ] )
]
::

code::
"c d".repetitionPattern(\degree, 4);
"c d".degree(4);
-> [
  ( 'octave': 4, 'dur': 0.5, 'accent': 0, 'midinote': 48 ),
  ( 'octave': 4, 'dur': 0.5, 'accent': 0, 'midinote': 50 )
]
::

code::
"c d".repetitionPattern(\freq, 4);
"c d".freq(4);
-> [
  ( 'octave': 4, 'dur': 0.5, 'accent': 0, 'midinote': 130.8127826503 ),
  ( 'octave': 4, 'dur': 0.5, 'accent': 0, 'midinote': 146.8323839587 )
]
::

code::
"60 48".repetitionPattern(\int);
"60 48".int;
-> [
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': 60 ),
  ( 'octave': 5, 'dur': 0.5, 'accent': 0, 'midinote': 48 )
]
::


SUBSECTION:: Bjorklund / Euclidean Rhythm

By taking advantage of the link::Classes/Bjorklund:: Quark, we are able to generate a link::Classes/String:: that represent the same rhythm. The valid args are code::k:: which represents the amount of notes distributed in code::n:: places, and code::rotate:: which will shift positions.

For example:

code::
"bd".bjorklund(4, 16).quote;
-> "bd r r r bd r r r bd r r r bd r r r"
::

code::
"bd".bjorklund(4, 16, 2).quote;
-> "r r bd r r r bd r r r bd r r r bd r"
::

Additionally, it's possible to pass more than one 'symbol' to a Bjorklund rhythm, such as "sn rm", which will distribute these symbols to each 'hit'. Therefore
creating a more coherent pattern.

For example:

code::
"sn rm".bjorklund(3,8).quote;
-> "sn r r rm r r sn r"
::

So, this creates a List of Events with 1/8 duration each.

code::
"sn rm".bjorklund(3,8).perc;
-> [
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': 38 ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': 37 ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': 38 ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest )
]
::

This method works with any kind of 'callback'.


SUBSECTION:: Custom MIDI Event Types

Currently, link::Classes/Repetition:: provides two custom link::Classes/Event:: types: code::\md:: and code::\cc::. Both are a simplification of a normal link::Classes/Event:: type code::\midi:: declaring by default code::~type::, code::~midiout::, code::~chan:: (code::9:: by default) and code::~amp::.
To use them you just need to call code::Repetition.initMIDI:: and code::Repetition.midiEventTypes:: .
Example:

code::
(
r = Repetition.new;
m = r.initMIDI("Midi Through", "Midi Through Port-0");
r.midiEventTypes;
)
::


SUBSECTION:: External Methods

Since we're working with a link::Classes/List:: of Events, pretty much any method that can be applied to a link::Classes/List::, can be applied here as well.
In addition to that, there's this list of methods that can be applied to:

LIST::
## code::mute()::, overwrites the amplitude of each Event to zero.
## code::stretch(n)::, adds code::\stretch, n:: to each Event.
## code::fast(n)::, shortcut for code::.stretch(1/n)::.
## code::slow(n)::, shortcut for code::.stretch(n)::.
## code::freeze(idx, times)::, at index code::idx::, will code::dup:: the amount of code::times::.
## code::duration(time)::, overwrites the duration of each Event to code::time::.
## code::with(... args)::, allows to overwrite any argument of each Event. Uses similar syntax as Pbind.
::



Each pattern holds the minimum information possible, such as note and duration, but normally we need to add more data to each pattern to become something "useful" (think of amplitude, synth parameters, envelope values, etc).

code::
(
~x =  // this is the nodeproxy
"bd sn" // and our simple pattern
.bjorklund(3,8) // converted to a a bjorklund rhythm
.perc // and now converted to a List of Events
.with(\amp, 0.9) // which now each Event has an addition argument, \amp, with a value of `0.9`
.ch(9) // and finally each one goes to MIDI Channel 9
)
::



Also, I've added the most common link::Classes/Pattern:: classes as methods, there isn't a really good reason other than it's more comfortable to type when chaining methods.

code::
(
16.collect{ |x| x + x.rand(x, x*2) }.stutter(8).scramble.pseq(rep: inf, offs: 0);
[1,2,3].pwrand([0.1,0.5,0.23].normalizeSum, inf).stutter(8);
)
::

The available methods are:

LIST::
## code::pseq::, takes two arguments: code::rep:: (repeats) and code::offs:: (offset).
## code::pshuf::, takes one argument: code::rep:: (repeats).
## code::prand::, takes one argument: code::rep:: (repeats).
## code::pxrand::, takes one argument: code::rep:: (repeats).
## code::pwrand::, takes two arguments: code::weights:: (weights) and code::rep:: (repeats).
## code::place::, takes two arguments: code::rep:: (repeats) and code::offs:: (offset).
::

Note that if you want to use them with a link::Classes/Repetition:: Pattern, you need to treat them as link::Classes/Stream::.
For example:

code::
(
x = "sn rm".bjorklund(3,8).perc.pseq.asStream;
x.nextN(5);
)

-> [
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': 38 ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': 37 ),
  ( 'octave': 0, 'dur': 0.125, 'accent': 0, 'midinote': rest )
]
::


SUBSECTION:: Actually playing something.

So far we learnt how to create a List of Events. And now we'll learn how to create sounds from it.

code::
(
~x =  // this is the nodeproxy
"bd sn" // and our simple pattern
.bjorklund(3,8) // converted to a a bjorklund rhythm
.perc // and now converted to a List of Events
.with(\amp, 0.9) // which now each Event has an addition argument, \amp, with a value of `0.9`
.ch(9) // and finally each one goes to MIDI Channel 9
)
::



SUBSECTION:: Booting up

And last but not least, the recommended way [*] to boot SuperCollider link::Classes/Server:: + link::Classes/ProxySpace:: with link::Classes/Repetition::

code::
(
r = Repetition.new;
m = r.initMIDI("Midi Through", "Midi Through Port-0");
p = r.getProxySpace;

r.midiEventTypes;  // setup repetition midi stuff
ProxyMixer(p); // and a nice proxymixer too
)
::

[*] At least, how I do it :-)


CLASSMETHODS::

METHOD:: new
Creates a Repetition instance, which will automatically boot the link::Classes/Server:: + link::Classes/ProxySpace::

ARGUMENT:: default_tempo
Defines the tempo clock for link::Classes/ProxySpace::

ARGUMENT:: quant
Defines the quantization for link::Classes/ProxySpace::

returns:: link::Classes/Repetition::


INSTANCEMETHODS::

METHOD:: start
Creates a Repetition instance, which will automatically boot the link::Classes/Server:: + link::Classes/ProxySpace::

ARGUMENT:: default_tempo
Defines the tempo clock for link::Classes/ProxySpace::

ARGUMENT:: quant
Defines the quantization for link::Classes/ProxySpace::

returns:: link::Classes/Repetition::


METHOD:: initSuperDirt
(describe method here)
Starts link::Classes/SuperDirt:: with pretty much default settings, except it starts with 8 orbits (4 stereo) instead of just 2

returns:: link::Classes/SuperDirt::


METHOD:: initMIDI
Starts link::Classes/MIDIClient:: if not running, and creates link::Classes/MIDIOut:: instance

ARGUMENT:: dev
Device name. See link::Classes/MIDIOut::

ARGUMENT:: port
Port name. See link::Classes/MIDIOut::

ARGUMENT:: latency
MIDI Latency. See link::Classes/MIDIOut::

returns:: link::Classes/MIDIOut::


METHOD:: midiEventTypes
Creates two link::Classes/Event:: types, code::\md:: and code::\cc::

returns:: link::Classes/Repetition::


METHOD:: on
Sends a Note On to a MIDI Channel

ARGUMENT:: chan
Channel number

ARGUMENT:: note
MIDI Note number

ARGUMENT:: vel
MIDI Velocity

returns:: link::Classes/Repetition::


METHOD:: off
Sends a Note Off to a MIDI Channel

ARGUMENT:: chan
Channel number

returns:: link::Classes/Repetition::


METHOD:: getProxySpace
Returns the link::Classes/ProxySpace:: instance

returns:: link::Classes/ProxySpace::
